#!/usr/bin/env bash
set -euo pipefail

# Secure bootstrap for autonomous agent tooling in GitHub Codespaces.
# This script only uses environment variables and does not write secrets to repository files.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "${SCRIPT_DIR}/../.." && pwd)"
SETTINGS_FILE="${ROOT_DIR}/.devcontainer/codespaces-settings.env"
# shellcheck source=scripts/codespaces/lib/github-auth.sh
. "${SCRIPT_DIR}/lib/github-auth.sh"

if [ -f "${SETTINGS_FILE}" ]; then
    # shellcheck disable=SC1090
    . "${SETTINGS_FILE}"
fi

readonly CODEX_CONFIG="${HOME}/.codex/config.toml"
readonly CLAUDE_SETTINGS_FILE="${HOME}/.claude/settings.json"
readonly AGENT_ENV_DIR="${HOME}/.config/core-service"
readonly AGENT_SECRETS_FILE="${AGENT_ENV_DIR}/agent-secrets.env"
readonly AGENT_BASHRC_FILE="${HOME}/.bashrc"
readonly AGENT_BASHRC_START="# BEGIN CORE-SERVICE AGENT ENV"
readonly AGENT_BASHRC_END="# END CORE-SERVICE AGENT ENV"

: "${CODEX_PROFILE_NAME:=openrouter}"
: "${CODEX_MODEL:=openai/gpt-5.2-codex}"
: "${CODEX_OPENROUTER_BASE_URL:=https://openrouter.ai/api/v1}"
: "${CODEX_REASONING_EFFORT:=high}"
: "${CODEX_REASONING_SUMMARY:=none}"
# Safer defaults; override by exporting CODEX_APPROVAL_POLICY/CODEX_SANDBOX_MODE.
: "${CODEX_APPROVAL_POLICY:=on-failure}"
: "${CODEX_SANDBOX_MODE:=workspace-write}"
: "${CODEX_ALLOW_UNSAFE_MODE:=0}"

: "${CLAUDE_DEFAULT_MODEL:=anthropic/claude-sonnet-4.5}"
: "${CLAUDE_OPENROUTER_BASE_URL:=https://openrouter.ai/api}"
: "${CLAUDE_PERMISSION_MODE:=bypassPermissions}"

: "${GH_HOST:=github.com}"
: "${GH_GIT_PROTOCOL:=ssh}"
: "${GH_PROMPT:=disabled}"
: "${CODESPACE_GIT_IDENTITY_NAME:=vilnacrm ai bot}"
: "${CODESPACE_GIT_IDENTITY_EMAIL:=info@vilnacrm.com}"

TMP_FILES=()
CS_GIT_IDENTITY_NAME=""
CS_GIT_IDENTITY_EMAIL=""
DETECTED_GIT_IDENTITY_NAME=""
DETECTED_GIT_IDENTITY_EMAIL=""

if [ -f "${AGENT_SECRETS_FILE}" ]; then
    # shellcheck disable=SC1090
    . "${AGENT_SECRETS_FILE}"
fi

cleanup_tmp_files() {
    local tmp_file
    for tmp_file in "${TMP_FILES[@]}"; do
        rm -f "${tmp_file}"
    done
}

track_tmp_file() {
    TMP_FILES+=("$1")
}

trap cleanup_tmp_files EXIT

configure_claude_openrouter_env() {
    export ANTHROPIC_AUTH_TOKEN="${OPENROUTER_API_KEY}"
    export ANTHROPIC_BASE_URL="${CLAUDE_OPENROUTER_BASE_URL}"
    # Blank native API key so Claude CLI uses AUTH_TOKEN (OpenRouter) instead.
    export ANTHROPIC_API_KEY=""
    export ANTHROPIC_MODEL="${CLAUDE_DEFAULT_MODEL}"
}

persist_agent_secrets_file() {
    local tmp_secrets_file
    tmp_secrets_file="$(mktemp)"
    track_tmp_file "${tmp_secrets_file}"

    {
        printf '# Generated by scripts/codespaces/setup-secure-agent-env.sh\n'
        printf 'export OPENROUTER_API_KEY=%q\n' "${OPENROUTER_API_KEY}"
        printf 'export ANTHROPIC_AUTH_TOKEN=%q\n' "${ANTHROPIC_AUTH_TOKEN}"
        printf 'export ANTHROPIC_BASE_URL=%q\n' "${ANTHROPIC_BASE_URL}"
        printf 'export ANTHROPIC_API_KEY=%q\n' "${ANTHROPIC_API_KEY}"
        printf 'export ANTHROPIC_MODEL=%q\n' "${ANTHROPIC_MODEL}"
        printf 'export CLAUDE_PERMISSION_MODE=%q\n' "${CLAUDE_PERMISSION_MODE}"
        if [ -n "${GH_AUTOMATION_TOKEN:-}" ]; then
            printf 'export GH_AUTOMATION_TOKEN=%q\n' "${GH_AUTOMATION_TOKEN}"
        fi
        # These checks read the current shell environment. They do not read values
        # already written above, so we explicitly cascade to persist both tokens.
        if [ -n "${GH_TOKEN:-}" ]; then
            printf 'export GH_TOKEN=%q\n' "${GH_TOKEN}"
        elif [ -n "${GH_AUTOMATION_TOKEN:-}" ]; then
            printf 'export GH_TOKEN=%q\n' "${GH_AUTOMATION_TOKEN}"
        fi
        if [ -n "${GITHUB_TOKEN:-}" ]; then
            printf 'export GITHUB_TOKEN=%q\n' "${GITHUB_TOKEN}"
        elif [ -n "${GH_TOKEN:-}" ]; then
            printf 'export GITHUB_TOKEN=%q\n' "${GH_TOKEN}"
        elif [ -n "${GH_AUTOMATION_TOKEN:-}" ]; then
            printf 'export GITHUB_TOKEN=%q\n' "${GH_AUTOMATION_TOKEN}"
        fi
        # Persist only bootstrap-managed git identity to login shells.
        if [ -n "${CS_GIT_IDENTITY_NAME:-}" ]; then
            printf 'export GIT_AUTHOR_NAME=%q\n' "${CS_GIT_IDENTITY_NAME}"
            printf 'export GIT_COMMITTER_NAME=%q\n' "${CS_GIT_IDENTITY_NAME}"
        fi
        if [ -n "${CS_GIT_IDENTITY_EMAIL:-}" ]; then
            printf 'export GIT_AUTHOR_EMAIL=%q\n' "${CS_GIT_IDENTITY_EMAIL}"
            printf 'export GIT_COMMITTER_EMAIL=%q\n' "${CS_GIT_IDENTITY_EMAIL}"
        fi
    } > "${tmp_secrets_file}"

    mkdir -p "${AGENT_ENV_DIR}"
    chmod 700 "${AGENT_ENV_DIR}"
    chmod 600 "${tmp_secrets_file}"
    mv "${tmp_secrets_file}" "${AGENT_SECRETS_FILE}"
}

ensure_shell_sources_agent_secrets() {
    local tmp_bashrc
    tmp_bashrc="$(mktemp)"
    track_tmp_file "${tmp_bashrc}"

    touch "${AGENT_BASHRC_FILE}"

    awk -v start="${AGENT_BASHRC_START}" -v end="${AGENT_BASHRC_END}" '
        $0 == start {skip=1; next}
        $0 == end {skip=0; next}
        skip == 0 {print}
    ' "${AGENT_BASHRC_FILE}" > "${tmp_bashrc}"

    cat >> "${tmp_bashrc}" <<'EOM'

# BEGIN CORE-SERVICE AGENT ENV
if [ -f "$HOME/.config/core-service/agent-secrets.env" ]; then
    . "$HOME/.config/core-service/agent-secrets.env"
fi
# END CORE-SERVICE AGENT ENV
EOM

    cat "${tmp_bashrc}" > "${AGENT_BASHRC_FILE}"
    rm -f "${tmp_bashrc}"
}

write_codex_config() {
    local tmp_config

    tmp_config="$(mktemp)"
    track_tmp_file "${tmp_config}"

    cat > "${tmp_config}" <<EOM
# Generated by scripts/codespaces/setup-secure-agent-env.sh
profile = "${CODEX_PROFILE_NAME}"

[profiles.${CODEX_PROFILE_NAME}]
model = "${CODEX_MODEL}"
model_provider = "openrouter"
model_reasoning_effort = "${CODEX_REASONING_EFFORT}"
model_reasoning_summary = "${CODEX_REASONING_SUMMARY}"
approval_policy = "${CODEX_APPROVAL_POLICY}"
sandbox_mode = "${CODEX_SANDBOX_MODE}"

[model_providers.openrouter]
name = "OpenRouter"
base_url = "${CODEX_OPENROUTER_BASE_URL}"
env_key = "OPENROUTER_API_KEY"
wire_api = "responses"
EOM

    mkdir -p "$(dirname "${CODEX_CONFIG}")"
    chmod 600 "${tmp_config}"
    mv "${tmp_config}" "${CODEX_CONFIG}"
}

write_claude_settings() {
    local tmp_settings

    tmp_settings="$(mktemp)"
    track_tmp_file "${tmp_settings}"

    jq -n \
        --arg model "${CLAUDE_DEFAULT_MODEL}" \
        --arg mode "${CLAUDE_PERMISSION_MODE}" \
        '{"model": $model, "permissions": {"defaultMode": $mode}}' > "${tmp_settings}"

    mkdir -p "$(dirname "${CLAUDE_SETTINGS_FILE}")"
    chmod 700 "$(dirname "${CLAUDE_SETTINGS_FILE}")"
    chmod 600 "${tmp_settings}"
    mv "${tmp_settings}" "${CLAUDE_SETTINGS_FILE}"
}

validate_codex_safety_settings() {
    if [ "${CODEX_APPROVAL_POLICY}" = "never" ] \
        && [ "${CODEX_SANDBOX_MODE}" = "danger-full-access" ] \
        && [ "${CODEX_ALLOW_UNSAFE_MODE}" != "1" ]; then
        cat >&2 <<'EOM'
Error: refusing unsafe Codex defaults.
Detected:
  CODEX_APPROVAL_POLICY=never
  CODEX_SANDBOX_MODE=danger-full-access

Set CODEX_ALLOW_UNSAFE_MODE=1 only when this is an intentional opt-in.
EOM
        exit 1
    fi
}

configure_git_identity() {
    local name email configured_name configured_email var

    CS_GIT_IDENTITY_NAME=""
    CS_GIT_IDENTITY_EMAIL=""
    DETECTED_GIT_IDENTITY_NAME=""
    DETECTED_GIT_IDENTITY_EMAIL=""

    # Empty author/committer env vars override git config and break commits.
    for var in GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL GIT_COMMITTER_NAME GIT_COMMITTER_EMAIL; do
        if [ -z "${!var:-}" ]; then
            unset "${var}" || true
        fi
    done

    name="${GIT_AUTHOR_NAME:-${GIT_COMMITTER_NAME:-}}"
    email="${GIT_AUTHOR_EMAIL:-${GIT_COMMITTER_EMAIL:-}}"
    configured_name="$(git config --global --get user.name 2>/dev/null || true)"
    configured_email="$(git config --global --get user.email 2>/dev/null || true)"

    if [ -z "${name}" ]; then
        name="${configured_name}"
    fi
    if [ -z "${email}" ]; then
        email="${configured_email}"
    fi

    if [ -n "${name}" ] && [ -n "${email}" ]; then
        DETECTED_GIT_IDENTITY_NAME="${name}"
        DETECTED_GIT_IDENTITY_EMAIL="${email}"
        return 0
    fi

    name="${CODESPACE_GIT_IDENTITY_NAME}"
    email="${CODESPACE_GIT_IDENTITY_EMAIL}"

    git config --global user.name "${name}"
    git config --global user.email "${email}"

    # Keep author/committer identity explicit and non-empty in login shells.
    export GIT_AUTHOR_NAME="${name}"
    export GIT_AUTHOR_EMAIL="${email}"
    export GIT_COMMITTER_NAME="${name}"
    export GIT_COMMITTER_EMAIL="${email}"

    CS_GIT_IDENTITY_NAME="${name}"
    CS_GIT_IDENTITY_EMAIL="${email}"
    DETECTED_GIT_IDENTITY_NAME="${name}"
    DETECTED_GIT_IDENTITY_EMAIL="${email}"
}

cs_require_command gh
cs_require_command jq
cs_require_command codex
cs_require_command claude
cs_ensure_gh_auth

if [ -z "${OPENROUTER_API_KEY:-}" ]; then
    cat >&2 <<'EOM'
Error: OPENROUTER_API_KEY is not set.
Provide OPENROUTER_API_KEY as a Codespaces secret.
EOM
    exit 1
fi

validate_codex_safety_settings
configure_git_identity
configure_claude_openrouter_env
persist_agent_secrets_file
ensure_shell_sources_agent_secrets
write_codex_config
write_claude_settings

# Persist repository-defined GH defaults for CLI behavior in each fresh Codespace.
gh config set git_protocol "${GH_GIT_PROTOCOL}" --host "${GH_HOST}" >/dev/null 2>&1 || true
gh config set prompt "${GH_PROMPT}" >/dev/null 2>&1 || true

echo "Secure agent environment is ready."
echo "GH auth: available (mode: ${CS_GH_AUTH_MODE:-unknown})."
echo "Git identity configured:"
echo "  - name: ${DETECTED_GIT_IDENTITY_NAME:-<unset>}"
echo "  - email: ${DETECTED_GIT_IDENTITY_EMAIL:-<unset>}"
echo "Codex configured:"
echo "  - config: ${CODEX_CONFIG}"
echo "  - model: ${CODEX_MODEL}"
echo "  - profile: ${CODEX_PROFILE_NAME}"
echo "Claude Code configured:"
echo "  - settings: ${CLAUDE_SETTINGS_FILE}"
echo "  - default model: ${CLAUDE_DEFAULT_MODEL}"
echo "  - default permission mode: ${CLAUDE_PERMISSION_MODE}"
echo "  - OpenRouter base URL: ${CLAUDE_OPENROUTER_BASE_URL}"
echo "Runtime secret env:"
echo "  - ${AGENT_SECRETS_FILE} (mode 600)"
